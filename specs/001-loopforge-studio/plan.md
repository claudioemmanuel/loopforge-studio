# Implementation Plan: Loopforge Studio

**Branch**: `001-loopforge-studio` | **Date**: 2026-02-12 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `specs/001-loopforge-studio/spec.md`

## Summary

Loopforge Studio is a self-hosted, visual workflow UI for AI-assisted coding. It provides a
seven-column Kanban board (Todo → Brainstorming → Planning → Ready → Executing → Done → Stuck)
where developers create tasks, collaboratively brainstorm with AI, approve AI-generated execution
plans, and watch live as a background worker commits code to feature branches on GitHub.
Multi-provider AI support (Anthropic, OpenAI, Google) is delivered through a pluggable
provider abstraction with user-supplied API keys stored encrypted at rest.

## Technical Context

**Language/Version**: TypeScript 5.x (Node.js 20 LTS for API, Vite + React 18 for frontend)
**Primary Dependencies**: Fastify (API), React 18 + shadcn/ui + TailwindCSS (frontend),
  Prisma (ORM), BullMQ (job queue), Socket.io (WebSocket), SSE (log streaming)
**Storage**: PostgreSQL 16 (primary data), Redis 7 (BullMQ job queue)
**Testing**: Vitest (unit + integration), Playwright (e2e)
**Target Platform**: Self-hosted Linux (Docker Compose); dev on macOS/Linux
**Project Type**: Web application (monorepo: `apps/api` + `apps/web` + `packages/shared`)
**Performance Goals**: AI chat response streaming starts within 5 seconds; execution logs
  within 2 seconds of each AI action; board WebSocket updates < 500ms
**Constraints**: All secrets AES-256-GCM encrypted; AI commits to feature branches only;
  per-repo execution serialization via BullMQ named queues
**Scale/Scope**: Single-tenant self-hosted; ~10 concurrent tasks; ~3 AI providers

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Check | Status |
|-----------|-------|--------|
| I. User-Controlled Workflow | Plan approval gate enforced: `PLANNING → READY` requires `ExecutionPlan.status = APPROVED`; worker only picks up `READY` tasks | ✅ PASS |
| II. Self-Hosted & BYOK | No platform keys; all AI calls use user-supplied keys from `ProviderConfig`; AES-256-GCM encryption confirmed in data model | ✅ PASS |
| III. Branch Isolation | Worker enforces `loopforge/<task-id>-<slug>` branch creation; API blocks attempts to commit to `main`/`master` | ✅ PASS |
| IV. Multi-Provider Abstraction | `AIProvider` interface with factory pattern; `ANTHROPIC`, `OPENAI`, `GOOGLE` enum; switchable per task | ✅ PASS |
| V. Observability | `ExecutionLog` entity captures every AI action; SSE streaming to UI; `AnalyticsEvent` for dashboard | ✅ PASS |
| Security & Data | GitHub tokens server-side only; JWT in cookies not URLs; API keys never in responses | ✅ PASS |
| Development Workflow | spec.md + plan.md complete before implementation; user stories independently testable | ✅ PASS |

**All gates pass. No complexity violations to justify.**

## Project Structure

### Documentation (this feature)

```text
specs/001-loopforge-studio/
├── plan.md              # This file
├── research.md          # Phase 0 — tech stack decisions
├── data-model.md        # Phase 1 — entities and state machine
├── quickstart.md        # Phase 1 — developer setup guide
├── contracts/
│   ├── api.openapi.yaml # REST + SSE API contract
│   └── websocket.md     # Socket.io board events contract
└── tasks.md             # Phase 2 — generated by /speckit.tasks
```

### Source Code (repository root)

```text
apps/
├── api/                         # Fastify backend
│   ├── src/
│   │   ├── auth/                # GitHub OAuth, JWT, session
│   │   ├── routes/              # REST route handlers
│   │   │   ├── tasks.ts
│   │   │   ├── repositories.ts
│   │   │   ├── chat.ts
│   │   │   ├── plans.ts
│   │   │   ├── logs.ts
│   │   │   ├── settings.ts
│   │   │   └── analytics.ts
│   │   ├── services/            # Business logic
│   │   │   ├── task.service.ts
│   │   │   ├── github.service.ts
│   │   │   ├── ai-provider.service.ts
│   │   │   └── encryption.service.ts
│   │   ├── workers/             # BullMQ job workers
│   │   │   └── execution.worker.ts
│   │   ├── providers/           # AI provider implementations
│   │   │   ├── provider.interface.ts
│   │   │   ├── anthropic.provider.ts
│   │   │   ├── openai.provider.ts
│   │   │   └── google.provider.ts
│   │   ├── realtime/            # Socket.io setup
│   │   │   └── board.gateway.ts
│   │   └── prisma/              # DB client + migrations
│   ├── prisma/
│   │   └── schema.prisma
│   └── tests/
│       ├── contract/
│       ├── integration/
│       └── unit/
│
├── web/                         # React frontend
│   ├── src/
│   │   ├── components/
│   │   │   ├── board/           # Kanban board + columns + cards
│   │   │   ├── chat/            # Brainstorming chat UI
│   │   │   ├── plan/            # Plan review + approve/reject
│   │   │   ├── logs/            # Execution log streaming view
│   │   │   ├── settings/        # Provider config + repo connect
│   │   │   └── analytics/       # Dashboard charts
│   │   ├── pages/
│   │   │   ├── BoardPage.tsx
│   │   │   ├── TaskPage.tsx
│   │   │   ├── SettingsPage.tsx
│   │   │   └── AnalyticsPage.tsx
│   │   ├── services/            # API client + SSE + Socket.io
│   │   │   ├── api.client.ts
│   │   │   ├── socket.client.ts
│   │   │   └── sse.client.ts
│   │   └── store/               # React state (Zustand or Context)
│   └── tests/
│
└── packages/
    └── shared/                  # Shared TypeScript types
        └── src/
            ├── types.ts         # Task, Stage, Provider enums etc.
            └── contracts.ts     # API request/response DTOs

docker-compose.yml
.env.example
```

**Structure Decision**: Web application (Option 2 pattern) with monorepo layout. Two apps
(`api`, `web`) share types via `packages/shared`. Docker Compose at root orchestrates all
four services (api, web, db, redis).

## Complexity Tracking

> No violations — all principles satisfied without exceptions.

---

## Phase 0: Research

**Status**: ✅ Complete — see [research.md](./research.md)

Key decisions resolved:
- **Frontend**: React 18 + shadcn/ui + TailwindCSS
- **Backend**: Fastify + TypeScript
- **ORM**: Prisma + PostgreSQL
- **Real-time**: Socket.io (board) + SSE (log streaming)
- **Queue**: BullMQ + Redis
- **Auth**: Custom server-side GitHub OAuth + JWT
- **AI abstraction**: Strategy Pattern with `AIProvider` interface
- **Structure**: pnpm workspaces monorepo
- **Deploy**: Docker Compose (4 services)

## Phase 1: Design

**Status**: ✅ Complete

| Artifact | Path | Status |
|----------|------|--------|
| Data model | [data-model.md](./data-model.md) | ✅ |
| API contract | [contracts/api.openapi.yaml](./contracts/api.openapi.yaml) | ✅ |
| WebSocket contract | [contracts/websocket.md](./contracts/websocket.md) | ✅ |
| Quickstart | [quickstart.md](./quickstart.md) | ✅ |

### Post-Design Constitution Check

All five principles confirmed by design artifacts:
- State machine transitions in `data-model.md` enforce approval gate (Principle I)
- `ProviderConfig.encryptedApiKey` + `User.encryptedGithubToken` fulfill Principle II
- `Commit.branch` constrained to feature branches in worker logic (Principle III)
- `AIProvider` interface in `apps/api/src/providers/` (Principle IV)
- `ExecutionLog` + `AnalyticsEvent` + SSE streaming endpoints (Principle V)

## Phase 2: Tasks

**Status**: ⏳ Pending — run `/speckit.tasks` to generate `tasks.md`
